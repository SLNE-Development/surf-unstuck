package dev.slne.antiexploit.bukkit.listener.listeners;

import java.util.Collection;

import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.block.data.Directional;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Vehicle;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.inventory.ItemStack;

import io.papermc.paper.event.block.BlockPreDispenseEvent;

public class DispenserListener implements Listener {

    // Prevents boats and minecarts from being dispensed into each other

    @EventHandler
    public void onDisepense(BlockPreDispenseEvent event) {
        ItemStack item = event.getItemStack();
        Block block = event.getBlock();
        String materialString = item.getType().toString();
        Directional directional = (Directional) block.getBlockData();
        Block targetBlock = block.getRelative(directional.getFacing());

        // Check if dispensed item is a minecart or boat
        if (!(materialString.contains("_BOAT") || materialString.contains("MINECART"))) {
            return;
        }

        // Check if it would even be placed down or just dropped
        if (!(targetBlock.getType().equals(Material.AIR) || targetBlock.getType().equals(Material.WATER)
                || targetBlock.getType().toString().contains("RAIL"))) {
            return;
        }

        World world = targetBlock.getWorld();
        Collection<Vehicle> vehicles = world.getNearbyEntitiesByType(Vehicle.class, targetBlock.getLocation(), 0.7, 0.7,
                0.7);

        // Check for existing boats or minecarts blocking the spawn
        for (Vehicle vehicle : vehicles) {
            if (!(vehicle.getType().equals(EntityType.BOAT) || vehicle.getType().toString().contains("MINECART"))) {
                return;
            }
            event.setCancelled(true);
            break;
        }
    }
}
